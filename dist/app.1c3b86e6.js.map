{"version":3,"sources":["js/wasmHandler.js","js/app.js"],"names":["combineMultithreadedData","multithreadingWorkers","multithreadingAmount","navigator","hardwareConcurrency","ctx","failedToGetThreadCount","undefined","webworkerLoaded","w","Promise","r","addEventListener","once","setHandlerSetting","name","val","updateHistoColorTimeout","combineImageData","combineImageDataIndex","cloneUseHistogramColoring","setWorkerSettings","i","postMessage","updateHistoColors","getWorkerSettings","lastGotWorkerSetting","init","_ctx","loadingCallback","startTime","performance","now","loads","worker","Worker","onmessage","handleMultithreaderReturn","push","histoColors","e","data","length","width","height","startX","imageData","ImageData","putImageData","lastWidth","lastHeight","console","log","renderFrame","xCam","yCam","scale","Array","stripWidth","Math","floor","waits","all","canvas","timeSinceStart","version","scaleFactor","autozoomInterval","frame","fpsArr","keys","autozoom","autozoomSpeed","locations","juliaSelection","juliaXEl","document","getElementById","juliaYEl","oninput","updateJuliaVectorFromSliders","introductionEl","WasmHandler","parseFloat","value","innerHTML","onclick","style","display","locationsEl","generateLocationButtons","loc","el","createElement","textContent","gotoLocation","appendChild","locationInterpolateProgressBarEl","transitionTopScale","transitionSpeed","locationName","find","x","oXCam","Number","oYCam","oScale","className","t","scaleT","transitionPoint","everZoomedOut","bezierInterpolate","abs","bezierBlend","min","resolve","setTimeout","transitionSpeedEl","a","b","bezierT","scaleCanvas","window","innerWidth","innerHeight","loadingEl","getContext","multithreadingInitLoadTime","generateKeyName","ctrlKey","shiftKey","key","toLowerCase","onresize","oncontextmenu","preventDefault","onkeydown","onkeyup","dragging","lastDragX","lastDragY","scaleX","scaleY","y","wheelHandler","zoom","deltaY","mouseInMandelBeforeX","clientX","mouseInMandelBeforeY","clientY","onmousedown","mouseDownHandler","which","setInterval","clearInterval","onmousemove","mouseMoveHandler","onmouseup","mouseUpHandler","onwheel","lastUpdateTime","panAmount","scalePanAmount","settingsEl","locationsContainerEl","introIterationAnimation","settingsShowing","debugEl","resScaleEl","maxIterationEl","setMaxIterationFromSlider","autozoomSpeedEl","linesBetweenEl","checked","histogramColoringEl","smoothColoringEl","combineDataEl","startLoadTime","update","timeNow","deltaTime","round","shift","setJuliaVector","newValue","parseInt","ceil","drawDebug","fps","arr","reduce","arrAverage","toFixed","toPrecision","requestAnimationFrame","coll","getElementsByClassName","classList","toggle","content","nextElementSibling","maxHeight"],"mappings":"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","file":"app.1c3b86e6.js","sourceRoot":"../src","sourcesContent":["export let combineMultithreadedData = true;\n\nlet multithreadingWorkers = [];\nexport let multithreadingAmount = navigator.hardwareConcurrency || 4; // Use 4 if can't get CPU core / thread count\nexport let failedToGetThreadCount = navigator.hardwareConcurrency === undefined;\n\nlet ctx;\n\n/*let linesBetweenColumns = false;\nexport function setLinesBetweenColumns(val) { // Allowing setting it externally\n  linesBetweenColumns = val;\n}*/\n\nconst webworkerLoaded = w => new Promise(r => w.addEventListener(\"message\", r, { once: true }));\n\nexport async function setHandlerSetting(name, val) {\n  switch (name) {\n    case 'combineMultithreadedData':\n      combineMultithreadedData = val;\n      break;\n  }\n}\n\nlet cloneUseHistogramColoring = false;\n\nexport async function setWorkerSettings(name, val) {\n  for (let i = 0; i < multithreadingAmount; i++) {\n    multithreadingWorkers[i].postMessage(['set', name, val]);\n  }\n\n  switch (name) {\n    case 'useHistogramColoring':\n      cloneUseHistogramColoring = val;\n      break;\n    case 'maxIterationColorScale':\n      return; // Don't update histo colors for updating the normal color scale\n  }\n\n  await updateHistoColors();\n\n  //updateHistoColors();\n}\n\nlet updateHistoColorTimeout;\n\nexport async function getWorkerSettings(name) {\n  multithreadingWorkers[0].postMessage(['get', name, undefined]);\n\n  await webworkerLoaded(multithreadingWorkers[0]);\n\n  return lastGotWorkerSetting;\n}\n\nexport async function init(_ctx, loadingCallback = () => {}) {\n  loadingCallback('Loading multithreading workers');\n\n  let startTime = performance.now();\n\n  ctx = _ctx;\n\n  let loads = [];\n  for (let i = 0; i < multithreadingAmount; i++) {\n    loadingCallback(`Spawning worker ${i + 1}`);\n\n    let worker = new Worker('wasmMultithread.js');\n\n    worker.onmessage = handleMultithreaderReturn;\n\n    multithreadingWorkers.push(worker);\n    loads.push(webworkerLoaded(worker));\n  }\n\n  for (let i = 0; i < multithreadingAmount; i++) {\n    loadingCallback(`Waiting for worker ${i + 1} to load`);\n    await loads[i];\n  }\n\n  loadingCallback('Loaded all multithreading workers');\n\n  return performance.now() - startTime;\n\n  //await Promise.all(loads);\n\n  //console.log(`${(performance.now() - startTime).toFixed(2)}ms`);\n\n  //await (new Promise(resolve => setTimeout(resolve, 1000)));\n}\n\nlet combineImageData;\nlet combineImageDataIndex;\n\nlet histoColors = [];\nlet lastGotWorkerSetting;\n\nfunction handleMultithreaderReturn(e) {\n  if (e.data === 'loaded') return;\n\n  if (e.data.length === 1) {\n    histoColors = e.data[0];\n\n    //console.log('aa', e.data);\n\n    return;\n  }\n\n  if (e.data.length === 2) {\n    lastGotWorkerSetting = e.data[1];\n\n    return;\n  }\n\n  let [i, width, height, data] = e.data;\n\n  let startX = (i * width);\n\n  let imageData = new ImageData(data, width, height);\n\n  if (combineMultithreadedData) {\n    combineImageData[combineImageDataIndex] = [imageData, startX];\n    combineImageDataIndex++;\n\n    if (combineImageDataIndex === multithreadingAmount) {\n      for (let i = 0; i < multithreadingAmount; i++) {\n        ctx.putImageData(combineImageData[i][0], combineImageData[i][1], 0);\n      }\n    }\n\n    return;\n  }\n\n  ctx.putImageData(imageData, startX, 0);\n}\n\nlet lastWidth = 0;\nlet lastHeight = 0;\n\nasync function updateHistoColors() {\n  //if (multithreadingWorkers[0] === undefined) return;\n  if (!cloneUseHistogramColoring) {\n    //return;\n  }\n\n  console.log(lastWidth, lastHeight);\n\n  multithreadingWorkers[0].postMessage([lastWidth, lastHeight]);\n\n  await webworkerLoaded(multithreadingWorkers[0]);\n}\n\nexport async function renderFrame(width, height, xCam, yCam, scale) {\n  if (lastWidth !== width || lastHeight !== height || histoColors.length === 0) {\n    lastWidth = width;\n    lastHeight = height;\n\n    await updateHistoColors();\n    //console.log(histoColors);\n    //if (histoColors.length === 0) await promise;\n  }\n\n  //console.log(histoColors);\n\n  //console.log(histoColors);\n\n  combineImageData = Array(multithreadingAmount);\n  combineImageDataIndex = 0;\n\n  let stripWidth = Math.floor(width / multithreadingAmount);\n\n  //let stripCurrent = 0;\n  let waits = [];\n  for (let i = 0; i < multithreadingAmount; i++) {\n    multithreadingWorkers[i].postMessage([i, stripWidth, width, height, xCam, yCam, scale, histoColors]);\n\n    //stripCurrent += stripWidth;\n\n    waits.push(webworkerLoaded(multithreadingWorkers[i]));\n  }\n\n  await Promise.all(waits);\n\n  //module.render_frame(ctx, width, height, xCam, yCam, scale);\n}","import * as WasmHandler from './wasmHandler';\n\n(async function () { let canvas, ctx;\nconst timeSinceStart = performance.now();\n\nconst version = 'v4.0.0';\n\nlet scaleFactor = 2;\n\nlet width = 0;\nlet height = 0;\n\nlet frame = 0;\nlet fpsArr = new Array(10);\n\nlet xCam = 0;\nlet yCam = 0;\n\nlet scale = 1.2;\n\nlet keys = [];\n\nlet autozoom = false;\nlet autozoomSpeed = 1;\nlet autozoomInterval;\n\nlet locations = [ // TODO: Require adding +0.5 to all X due to xCam shift in Rust instead of in JS\n  {\n    name: 'Overview',\n    xCam: 0,\n    yCam: 0,\n    scale: 1.2\n  },\n  {\n    name: 'Left Mandelbrots',\n    xCam: -1.16,\n    yCam: 0,\n    scale: 0.20\n  },\n  {\n    name: 'Main Left Mandelbrot',\n    xCam: -1.26,\n    yCam: 0,\n    scale: 0.03\n  },\n  {\n    name: 'A Right Mandelbrot',\n    xCam: 0.9322,\n    yCam: 0.2278,\n    scale: 0.003\n  },\n  {\n    name: 'A Top Mandelbrot',\n    xCam: 0.339195,\n    yCam: -1.0338,\n    scale: 0.01203\n  },\n  {\n    name: 'Main Left Left Left Mandelbrot',\n    xCam: -1.2877647,\n    yCam: 0.00000030719355,\n    scale: 0.0000059845\n  }\n];\n\nlet juliaSelection = 0;\n\nconst juliaXEl = document.getElementById('juliaX');\nconst juliaYEl = document.getElementById('juliaY');\n\njuliaXEl.oninput = updateJuliaVectorFromSliders;\n\njuliaYEl.oninput = updateJuliaVectorFromSliders;\n\nfunction setJuliaVector() {\n  let x = 0;\n  let y = 0;\n\n  switch (juliaSelection) {\n    case 0:\n      //x = 0;\n      //y = 0;\n      break;\n    case 1:\n      x = -0.4;\n      y = 0.6;\n      break;\n    case 2:\n      x = 0.285;\n      // y = 0;\n      break;\n    case 3:\n      x = 0.285;\n      y = 0.01;\n      break;\n    case 4:\n      x = 0.45;\n      y = 0.1428;\n      break;\n    case 5:\n      x = -0.70176;\n      y = -0.3842;\n      break;\n    case 6:\n      x = -0.835;\n      y = -0.2321;\n      break;\n    case 7:\n      x = -0.8;\n      y = 0.156;\n      break;\n    case 8:\n      x = -0.7269;\n      y = 0.1889;\n      break;\n    case 9:\n    default:\n      // x = 0;\n      y = -0.8;\n      break;\n  }\n\n  juliaXEl.value = x;\n  juliaYEl.value = y;\n\n  updateJuliaVectorFromSliders();\n}\n\nlet juliaAnimationState = true;\nlet juliaAnimationFirst = true;\n\nfunction juliaAnimation() {\n  if (juliaAnimationFirst) {\n    maxIterationEl.value = 10;\n  }\n\n  if (juliaAnimationState) {\n    juliaXEl.value = parseFloat(juliaXEl.value) - 0.04;\n    if (juliaXEl.value < -1.9) juliaAnimationState = false;\n  } else {\n    juliaXEl.value = parseFloat(juliaXEl.value) + 0.04;\n    if (juliaXEl.value > -0.05) juliaAnimationState = true;\n  }\n\n  setMaxIterationFromSlider();\n\n  updateJuliaVectorFromSliders();\n\n  //requestAnimationFrame(juliaAnimation);\n\n  if (juliaXEl.value < 0.6) {\n    //juliaXEl.value = juliaXEl.value + 0.01;\n  }\n}\n\nconst introductionEl = document.getElementById('introduction');\n\nintroductionEl.innerHTML = `Welcome to MandelWeb!\n\nClicking this closes this introduction panel, however if you have never used this before it is recommended you read below.\n\nKeyboard Controls:\n<kbd>Ctrl</kbd> + <kbd>+</kbd> or <kbd>Z</kbd>: Zoom In\n<kbd>Ctrl</kbd> + <kbd>-</kbd> or <kbd>X</kbd>: Zoom Out\n\n<kbd>W</kbd> or <kbd>🠩</kbd>: Move / Pan Up\n<kbd>A</kbd> or <kbd>🠨</kbd>: Move / Pan Left\n<kbd>S</kbd> or <kbd>🠫</kbd>: Move / Pan Down\n<kbd>D</kbd> or <kbd>🠪</kbd>: Move / Pan Right\n\n<kbd>H</kbd>: Hide Settings Panel (top left)\n<kbd>Shift</kbd> + <kbd>H</kbd>: Hide Locations (top right)`; // Parcel compacts / removes spacing of text\n\nintroductionEl.onclick = () => {\n  introductionEl.style.display = 'none';\n};\n\nfunction updateJuliaVectorFromSliders() {\n  WasmHandler.setWorkerSettings('juliaVectorX', parseFloat(juliaXEl.value));\n  WasmHandler.setWorkerSettings('juliaVectorY', parseFloat(juliaYEl.value));\n}\n\nconst locationsEl = document.getElementById('locations');\nfunction generateLocationButtons() {\n  for (let loc of locations) {\n    let el = document.createElement('button');\n    el.textContent = loc.name;\n    el.onclick = function () { gotoLocation(this.textContent); };\n\n    locationsEl.appendChild(el);\n  }\n}\n\ngenerateLocationButtons();\n\nconst locationInterpolateProgressBarEl = document.getElementById('locationInterpolateProgressBar');\nlet transitionTopScale = 1.19;\nlet transitionSpeed = 1;\n\nasync function gotoLocation(locationName) {\n  let loc = locations.find((x) => x.name === locationName);\n\n  let oXCam = Number(xCam);\n  let oYCam = Number(yCam);\n  let oScale = Number(scale);\n\n  locationInterpolateProgressBarEl.value = 0;\n  locationInterpolateProgressBarEl.className = 'show';\n\n  let t = 0;\n  let scaleT = 0;\n\n  let transitionPoint = [-1, 0];\n  let everZoomedOut = false;\n  while (t < 1 || scaleT < 1) {/// || (xCam !== loc.xCam && yCam !== loc.yCam && scale !== loc.scale)) {\n    if (t < 1) {\n      xCam = bezierInterpolate(oXCam, loc.xCam, t);\n      yCam = bezierInterpolate(oYCam, loc.yCam, t);\n    }\n\n    if ((Math.abs(xCam - loc.xCam) > 0.8 || Math.abs(yCam - loc.yCam) > 0.8) && (transitionTopScale > loc.scale && transitionTopScale > scale && transitionTopScale > oScale)) {\n      everZoomedOut = true;\n      if (transitionPoint[0] !== 1) {\n        transitionPoint = [1, scale];\n        scaleT = 0;\n      }\n\n      scale = bezierInterpolate(transitionPoint[1], transitionTopScale, scaleT);\n    } else {\n      if (transitionPoint[0] !== 0) {\n        transitionPoint = [0, scale];\n        scaleT = 0;\n      }\n\n      scale = bezierInterpolate(transitionPoint[1], loc.scale, scaleT);\n    }\n\n    t += 0.005;\n    scaleT += everZoomedOut ? 0.007 : 0.005;\n    if (scaleT > 1) scaleT = 1;\n    if (t > 1) t = 1;\n\n    locationInterpolateProgressBarEl.value = bezierBlend(Math.min(t, 1));\n\n    await (new Promise(resolve => setTimeout(resolve, 10 / transitionSpeed)));\n  }\n\n  locationInterpolateProgressBarEl.className = '';\n\n  //gotoLocationInterval = setInterval(() => { stepToLocation(loc); }, 10);\n}\n\nlet transitionSpeedEl = document.getElementById('transitionSpeed');\n\ntransitionSpeedEl.oninput = () => {\n  transitionSpeed = parseFloat(transitionSpeedEl.value);\n  console.log(transitionSpeed);\n};\n\nfunction bezierInterpolate(a, b, t) {\n  let bezierT = bezierBlend(t);\n\n  return (1 - bezierT) * a + bezierT * b;\n}\n\nfunction bezierBlend(t) {\n  return t * t * (3 - 2 * t);\n}\n\nfunction scaleCanvas() {\n  width = Math.floor(window.innerWidth / scaleFactor);\n  height = Math.floor(window.innerHeight / scaleFactor);\n\n  canvas.width = width;\n  canvas.height = height;\n\n  canvas.style.width = `${window.innerWidth}px`;\n  canvas.style.height = `${window.innerHeight}px`;\n}\n\nlet loadingEl = document.getElementById('loading');\n\ncanvas = document.getElementById('canvas');\nctx = canvas.getContext('2d');\n\nconst multithreadingInitLoadTime = await WasmHandler.init(ctx, (x) => {\n  loadingEl.textContent = x;\n\n  if (x === 'Loaded all multithreading workers') {\n    loadingEl.textContent = x;\n  }\n});\n\nscaleCanvas();\nwindow.onresize = scaleCanvas;\n\ndocument.oncontextmenu = function(e) {\n  e.preventDefault();\n  return false;\n};\n\nfunction generateKeyName(e) {\n  return (e.ctrlKey ? 'ctrl_' : '') + (e.shiftKey ? 'shift_' : '') + e.key.toLowerCase();\n}\n  \ndocument.onkeydown = function(e) {\n  let name = generateKeyName(e);\n\n  if (keys[name] !== 'override') keys[name] = true;\n\n  if (name === 'ctrl_=' || name === 'ctrl_-') {\n    e.preventDefault();\n  }\n};\n\ndocument.onkeyup = function(e) {\n  keys[generateKeyName(e)] = false;\n};\n\nlet dragging = false;\nlet lastDragX = 0;\nlet lastDragY = 0;\n\nfunction mousePanAmount() {\n  return 0.0025 * scale;\n}\n\nfunction mouseDownHandler(e) {\n  if (e.which === 3) { // Right click - auto zoom\n    if (autozoom === false) {\n      autozoom = {clientX: e.clientX, clientY: e.clientY, deltaY: -autozoomSpeed};\n      autozoomInterval = setInterval(() => { wheelHandler(autozoom); }, 10);\n    } else {\n      clearInterval(autozoomInterval);\n      autozoom = false;\n    }\n\n    return;\n  }\n\n  dragging = true;\n\n  lastDragX = e.clientX;\n  lastDragY = e.clientY;\n\n  //WasmHandler.setHandlerSetting('combineMultithreadedData', true);\n}\n\nfunction mouseMoveHandler(e) {\n  if (!dragging) return;\n\n  //let diffX = x - lastDragX;\n  //let diffY = y - lastDragY;\n\n  let mouseInMandelBeforeX = scaleX(e.clientX / scaleFactor) - xCam;\n  let mouseInMandelBeforeY = scaleY(e.clientY / scaleFactor) - yCam;\n\n  if (lastDragX === 0 && lastDragY === 0) {\n    lastDragX = mouseInMandelBeforeX;\n    lastDragY = mouseInMandelBeforeY;\n  }\n\n  console.log(mouseInMandelBeforeX, lastDragX);\n  console.log(mouseInMandelBeforeY, lastDragY);\n\n  xCam -= mouseInMandelBeforeX - lastDragX; // * mousePanAmount();\n  yCam -= mouseInMandelBeforeY - lastDragY; // * mousePanAmount();\n\n  lastDragX = mouseInMandelBeforeX;\n  lastDragY = mouseInMandelBeforeY;\n}\n\nfunction mouseUpHandler(e) {\n  dragging = false;\n\n  //WasmHandler.setHandlerSetting('combineMultithreadedData', false);\n}\n\nfunction scaleX(x) {\n  return ((x / (width / 3.5)) - 1.75) * scale + xCam;\n}\n\nfunction scaleY(y) {\n  return (((y / (height / 2.0)) - 1.0)) * scale + yCam;\n}\n\nfunction wheelHandler(e) {\n  let zoom = (e.deltaY * 0.001);\n\n  //xCam -= ((scaleX(e.clientX / scaleFactor) * zoom) - xCam) / scaleFactor;\n\n  let mouseInMandelBeforeX = scaleX(e.clientX / scaleFactor) - xCam;\n  let mouseInMandelBeforeY = scaleY(e.clientY / scaleFactor) - yCam;\n\n  //console.log(mouseInMandelBeforeX);\n\n  scale *= 1 + zoom;\n\n  xCam -= (scaleX(e.clientX / scaleFactor) - xCam) - mouseInMandelBeforeX;\n\n  yCam -= (scaleY(e.clientY / scaleFactor) - yCam) - mouseInMandelBeforeY;\n\n  //let diffX = (scaleX(e.clientX / scaleFactor) - xCam) + mouseInMandelBeforeX;\n  //console.log(diffX)\n\n  //xCam += diffX;\n\n  //xCam -= scaleX(e.clientX) * zoom / scaleFactor;\n\n  //xCam = xCam - scaleX(e.clientX / window.innerWidth * (sWidthAfter - sWidthBefore));\n  //yCam = yCam - scaleY(e.clientY / window.innerHeight * (sHeightAfter - sHeightBefore));\n\n  if (e.preventDefault) e.preventDefault();\n}\n\ncanvas.onmousedown = mouseDownHandler;\ncanvas.onmousemove = mouseMoveHandler;\ncanvas.onmouseup = mouseUpHandler;\n\ncanvas.onwheel = wheelHandler;\n\nlet lastUpdateTime = performance.now();\n\nlet panAmount = 0.02;\n\nfunction scalePanAmount() {\n  return panAmount * scale;\n}\n\nlet settingsEl = document.getElementById('settings');\nlet locationsContainerEl = document.getElementById('locationsContainer');\n\nlet introIterationAnimation = false;\n\nlet settingsShowing = true;\n\nasync function update() {\n  let timeNow = performance.now();\n  let deltaTime = (timeNow - lastUpdateTime) / 1000;\n  lastUpdateTime = timeNow;\n\n  //juliaAnimation();\n\n  fpsArr.push(Math.round(1 / deltaTime));\n  if (fpsArr.length > 10) fpsArr.shift();\n\n  if (keys['w'] || keys['arrowup']) {\n    yCam -= scalePanAmount();\n  }\n\n  if (keys['s'] || keys['arrowdown']) {\n    yCam += scalePanAmount();\n  }\n\n  if (keys['a'] || keys['arrowleft']) {\n    xCam -= scalePanAmount();\n  }\n\n  if (keys['d'] || keys['arrowright']) {\n    xCam += scalePanAmount();\n  }\n\n  if (keys['z'] || keys['ctrl_=']) {\n    scale *= 0.99;\n  }\n\n  if (keys['x'] || keys['ctrl_-']) {\n    scale *= 1.01;\n  }\n\n  if (keys['0'] === true) {\n    gotoLocation(locations[0].name);\n    keys['0'] = 'override';\n  }\n\n  if (keys[']'] === true) {\n    juliaSelection++;\n    if (juliaSelection > 9) juliaSelection = 0;\n    setJuliaVector();\n\n    keys[']'] = 'override';\n  }\n\n  if (keys['h'] === true) {\n    settingsShowing = !settingsShowing;\n\n    settingsEl.style.display = settingsShowing ? 'block' : 'none';\n\n    keys['h'] = 'override';\n  }\n\n  if (keys['shift_h'] === true) {\n    locationsContainerEl.style.display = locationsContainerEl.style.display === 'block' ? 'none' : 'block';\n\n    keys['shift_h'] = 'override';\n  }\n\n  await WasmHandler.renderFrame(width, height, xCam, yCam, scale);\n\n  if (introIterationAnimation) {\n    let newValue = parseInt(maxIterationEl.value);\n    maxIterationEl.value = Math.ceil(newValue * 1.5); // > 100 ? newValue + 7 : newValue;\n\n    if (newValue > 300) { // || Object.values(keys).some((x) => x)) { // If maxIteration reaches 500 or any keys pressed\n      maxIterationEl.value = 1000;\n      introIterationAnimation = false;\n    }\n\n    await setMaxIterationFromSlider();\n  }\n\n  frame++;\n\n  if (settingsShowing) drawDebug();\n\n  requestAnimationFrame(update);\n}\n\nlet debugEl = document.getElementById('debug');\n\nlet resScaleEl = document.getElementById('resScale');\n\nresScaleEl.oninput = () => {\n  scaleFactor = resScaleEl.value;\n\n  scaleCanvas();\n};\n\nlet maxIterationEl = document.getElementById('maxIteration');\n\nasync function setMaxIterationFromSlider() {\n  await WasmHandler.setWorkerSettings('maxIteration', maxIterationEl.value);\n  await WasmHandler.setWorkerSettings('maxIterationColorScale', 255 / maxIterationEl.value);\n}\n\nmaxIterationEl.oninput = setMaxIterationFromSlider;\n\nlet autozoomSpeedEl = document.getElementById('autozoomSpeed');\n\nautozoomSpeedEl.oninput = () => {\n  autozoomSpeed = autozoomSpeedEl.value;\n  if (autozoom !== false) autozoom.deltaY = -autozoomSpeed;\n}\n\nlet linesBetweenEl = document.getElementById('linesBetween');\n\nlinesBetweenEl.oninput = () => {\n  WasmHandler.setWorkerSettings('linesBetweenMultithreadColumns', linesBetweenEl.checked);\n};\n\nlet histogramColoringEl = document.getElementById('histogramColoring');\n\nhistogramColoringEl.oninput = () => {\n  WasmHandler.setWorkerSettings('usehistogramColoring', histogramColoringEl.checked);\n};\n\nlet smoothColoringEl = document.getElementById('smoothColoring');\n\nsmoothColoringEl.oninput = () => {\n  WasmHandler.setWorkerSettings('useSmoothColoring', smoothColoringEl.checked);\n};\n\nlet combineDataEl = document.getElementById('combineData');\n\ncombineDataEl.oninput = () => {\n  WasmHandler.setHandlerSetting('combineMultithreadedData', combineDataEl.checked);\n};\n\nfunction arrAverage(arr) {\n  return arr.reduce((a, b) => a + b) / arr.length;\n}\n\nasync function drawDebug() {\n  let fps = Math.round(arrAverage(fpsArr));\n\n  debugEl.textContent = `${version}\n\nLoad Time - ${startLoadTime.toFixed(2)}ms:\n  Multithreading: ${multithreadingInitLoadTime.toFixed(2)}ms\n\nFrames: ${frame}, FPS: ${fps}\n\nPosition Information:\n  Camera Position: ${xCam.toPrecision(8)}, ${yCam.toPrecision(8)}\n  Scale: ${scale.toPrecision(8)}\n\nResolution:\n  Scaled: ${width}x${height}\n  Scale Factor: ${scaleFactor}\n  Raw: ${window.innerWidth}x${window.innerHeight}\n\nMultithreading:\n  Workers (Threads): ${WasmHandler.multithreadingAmount} (Assumed: ${WasmHandler.failedToGetThreadCount})`;\n\n//Memory (Heap): ${(window.performance.memory.usedJSHeapSize / 1000000).toFixed(2)}MB used / ${(window.performance.memory.totalJSHeapSize / 1000000).toFixed(2)}MB total`;\n}\n\n/*async function autoGeneratePerformance() {\n  let times = [];\n\n  for (let i = 0; i < 2; i++) {\n    let startTime = performance.now();\n\n    await WasmHandler.renderFrame(width, height, xCam, yCam, scale);\n\n    times.push(performance.now() - startTime);\n  }\n\n  let timeTaken = arrAverage(times);\n\n  loadingEl.textContent = `Auto modifying values for good performance... (${timeTaken.toFixed(0)}ms / ${(1000 / 15).toFixed(0)}ms)`;\n\n  if (timeTaken < 1000 / 15) {\n    let current = Number(maxIterationEl.value);\n    maxIterationEl.value = current + 20; //(parseInt(maxIterationEl.value) - 5).toString();\n    setMaxIterationFromSlider();\n\n    await (new Promise(resolve => setTimeout(resolve, 10)));\n\n    await autoGeneratePerformance();\n  }\n}*/\n\n/*async function increaseMaxIterationAnimation() {\n  await (new Promise(resolve => setTimeout(resolve, 200)));\n\n  if (maxIterationEl.value < 500) {\n    maxIterationEl.value = parseInt(maxIterationEl.value) + 10;\n    console.log(maxIterationEl.value);\n    setMaxIterationFromSlider();\n\n    //await (new Promise(resolve => setTimeout(resolve, 100)));\n\n    await increaseMaxIterationAnimation();\n  }\n}*/\n\nloadingEl.className = 'hide';\n//increaseMaxIterationAnimation();\n\n\n//loadingEl.textContent = 'Auto modifying values for good performance...';\n\n//await autoGeneratePerformance();\n\nconst startLoadTime = performance.now() - timeSinceStart;\n\nupdate();\n\nvar coll = document.getElementsByClassName(\"collapsible\");\nvar i;\n\nfor (i = 0; i < coll.length; i++) {\n  coll[i].addEventListener(\"click\", function() {\n    this.classList.toggle(\"active\");\n    var content = this.nextElementSibling;\n    if (content.style.maxHeight) {\n      content.style.maxHeight = null;\n    } else {\n      content.style.maxHeight = \"none\"; //content.scrollHeight + \"px\";\n    }\n  });\n}\n})();"]}