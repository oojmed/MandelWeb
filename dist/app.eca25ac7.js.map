{"version":3,"sources":["js/wasmHandler.js","js/app.js"],"names":["combineMultithreadedData","multithreadingWorkers","multithreadingAmount","navigator","hardwareConcurrency","ctx","failedToGetThreadCount","undefined","webworkerLoaded","w","Promise","r","addEventListener","once","setHandlerSetting","name","val","setWorkerSettings","i","postMessage","init","_ctx","loadingCallback","startTime","performance","now","loads","worker","Worker","onmessage","handleMultithreaderReturn","push","combineImageData","combineImageDataIndex","e","data","width","height","startX","imageData","ImageData","putImageData","renderFrame","xCam","yCam","scale","Array","stripWidth","Math","floor","waits","all","canvas","timeSinceStart","version","scaleFactor","autozoomInterval","frame","fpsArr","keys","autozoom","autozoomSpeed","locations","juliaSelection","juliaXEl","document","getElementById","juliaYEl","oninput","updateJuliaVectorFromSliders","introductionEl","WasmHandler","parseFloat","value","onclick","style","display","locationsEl","generateLocationButtons","loc","el","createElement","textContent","gotoLocation","appendChild","locationInterpolateProgressBarEl","transitionTopScale","transitionSpeed","locationName","find","x","oXCam","Number","oYCam","oScale","className","t","scaleT","transitionPoint","everZoomedOut","bezierInterpolate","abs","bezierBlend","min","resolve","setTimeout","transitionSpeedEl","a","b","bezierT","scaleCanvas","window","innerWidth","innerHeight","console","log","loadingEl","getContext","multithreadingInitLoadTime","generateKeyName","ctrlKey","shiftKey","key","toLowerCase","onresize","oncontextmenu","preventDefault","onkeydown","onkeyup","dragging","lastDragX","lastDragY","scaleX","scaleY","y","wheelHandler","zoom","deltaY","mouseInMandelBeforeX","clientX","mouseInMandelBeforeY","clientY","onmousedown","mouseDownHandler","which","setInterval","clearInterval","onmousemove","mouseMoveHandler","onmouseup","mouseUpHandler","onwheel","lastUpdateTime","panAmount","scalePanAmount","settingsEl","locationsContainerEl","introIterationAnimation","settingsShowing","debugEl","resScaleEl","maxIterationEl","setMaxIterationFromSlider","autozoomSpeedEl","linesBetweenEl","checked","borderTracingEl","combineDataEl","startLoadTime","update","timeNow","deltaTime","round","length","shift","newValue","parseInt","ceil","setJuliaVector","drawDebug","fps","arr","reduce","arrAverage","toFixed","toPrecision","memory","usedJSHeapSize","totalJSHeapSize","requestAnimationFrame"],"mappings":"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","file":"app.eca25ac7.js","sourceRoot":"../src","sourcesContent":["export let combineMultithreadedData = true;\n\nlet multithreadingWorkers = [];\nexport let multithreadingAmount = navigator.hardwareConcurrency || 4; // Use 4 if can't get CPU core / thread count\nexport let failedToGetThreadCount = navigator.hardwareConcurrency === undefined;\n\nlet ctx;\n\n/*let linesBetweenColumns = false;\nexport function setLinesBetweenColumns(val) { // Allowing setting it externally\n  linesBetweenColumns = val;\n}*/\n\nconst webworkerLoaded = w => new Promise(r => w.addEventListener(\"message\", r, { once: true }));\n\nexport async function setHandlerSetting(name, val) {\n  switch (name) {\n    case 'combineMultithreadedData':\n      combineMultithreadedData = val;\n      break;\n  }\n}\n\nexport async function setWorkerSettings(name, val) {\n  for (let i = 0; i < multithreadingAmount; i++) {\n    multithreadingWorkers[i].postMessage([name, val]);\n  }\n}\n\nexport async function init(_ctx, loadingCallback = () => {}) {\n  loadingCallback('Loading multithreading workers');\n\n  let startTime = performance.now();\n\n  ctx = _ctx;\n\n  let loads = [];\n  for (let i = 0; i < multithreadingAmount; i++) {\n    loadingCallback(`Spawning worker ${i + 1}`);\n\n    let worker = new Worker('wasmMultithread.js');\n\n    worker.onmessage = handleMultithreaderReturn;\n\n    multithreadingWorkers.push(worker);\n    loads.push(webworkerLoaded(worker));\n  }\n\n  for (let i = 0; i < multithreadingAmount; i++) {\n    loadingCallback(`Waiting for worker ${i + 1} to load`);\n    await loads[i];\n  }\n\n  loadingCallback('Loaded all multithreading workers');\n\n  return performance.now() - startTime;\n\n  //await Promise.all(loads);\n\n  //console.log(`${(performance.now() - startTime).toFixed(2)}ms`);\n\n  //await (new Promise(resolve => setTimeout(resolve, 1000)));\n}\n\nlet combineImageData;\nlet combineImageDataIndex;\nfunction handleMultithreaderReturn(e) {\n  if (e.data === 'loaded') return;\n\n  let [i, width, height, data] = e.data;\n\n  let startX = (i * width);\n\n  let imageData = new ImageData(data, width, height);\n\n  if (combineMultithreadedData) {\n    combineImageData[combineImageDataIndex] = [imageData, startX];\n    combineImageDataIndex++;\n\n    if (combineImageDataIndex === multithreadingAmount) {\n      for (let i = 0; i < multithreadingAmount; i++) {\n        ctx.putImageData(combineImageData[i][0], combineImageData[i][1], 0);\n      }\n    }\n\n    return;\n  }\n\n  ctx.putImageData(imageData, startX, 0);\n}\n\nexport async function renderFrame(width, height, xCam, yCam, scale) {\n  combineImageData = Array(multithreadingAmount);\n  combineImageDataIndex = 0;\n\n  let stripWidth = Math.floor(width / multithreadingAmount);\n\n  //let stripCurrent = 0;\n  let waits = [];\n  for (let i = 0; i < multithreadingAmount; i++) {\n    multithreadingWorkers[i].postMessage([i, stripWidth, width, height, xCam, yCam, scale]);\n\n    //stripCurrent += stripWidth;\n\n    waits.push(webworkerLoaded(multithreadingWorkers[i]));\n  }\n\n  await Promise.all(waits);\n\n  //module.render_frame(ctx, width, height, xCam, yCam, scale);\n}","import * as WasmHandler from './wasmHandler';\n\n(async function () { let canvas, ctx;\nconst timeSinceStart = performance.now();\n\nconst version = 'v3.0.0';\n\nlet scaleFactor = 2;\n\nlet width = 0;\nlet height = 0;\n\nlet frame = 0;\nlet fpsArr = new Array(10);\n\nlet xCam = 0;\nlet yCam = 0;\n\nlet scale = 1.2;\n\nlet keys = [];\n\nlet autozoom = false;\nlet autozoomSpeed = 1;\nlet autozoomInterval;\n\nlet locations = [ // TODO: Require adding +0.5 to all X due to xCam shift in Rust instead of in JS\n  {\n    name: 'Overview',\n    xCam: 0,\n    yCam: 0,\n    scale: 1.2\n  },\n  {\n    name: 'Left Mandelbrots',\n    xCam: -1.16,\n    yCam: 0,\n    scale: 0.20\n  },\n  {\n    name: 'Main Left Mandelbrot',\n    xCam: -1.26,\n    yCam: 0,\n    scale: 0.03\n  },\n  {\n    name: 'A Right Mandelbrot',\n    xCam: 0.9322,\n    yCam: 0.2278,\n    scale: 0.003\n  },\n  {\n    name: 'A Top Mandelbrot',\n    xCam: 0.339195,\n    yCam: -1.0338,\n    scale: 0.01203\n  },\n  {\n    name: 'Main Left Left Left Mandelbrot',\n    xCam: -1.2877647,\n    yCam: 0.00000030719355,\n    scale: 0.0000059845\n  }\n];\n\nlet juliaSelection = 0;\n\nconst juliaXEl = document.getElementById('juliaX');\nconst juliaYEl = document.getElementById('juliaY');\n\njuliaXEl.oninput = updateJuliaVectorFromSliders;\n\njuliaYEl.oninput = updateJuliaVectorFromSliders;\n\nfunction setJuliaVector() {\n  let x = 0;\n  let y = 0;\n\n  switch (juliaSelection) {\n    case 0:\n      //x = 0;\n      //y = 0;\n      break;\n    case 1:\n      x = -0.4;\n      y = 0.6;\n      break;\n    case 2:\n      x = 0.285;\n      // y = 0;\n      break;\n    case 3:\n      x = 0.285;\n      y = 0.01;\n      break;\n    case 4:\n      x = 0.45;\n      y = 0.1428;\n      break;\n    case 5:\n      x = -0.70176;\n      y = -0.3842;\n      break;\n    case 6:\n      x = -0.835;\n      y = -0.2321;\n      break;\n    case 7:\n      x = -0.8;\n      y = 0.156;\n      break;\n    case 8:\n      x = -0.7269;\n      y = 0.1889;\n      break;\n    case 9:\n    default:\n      // x = 0;\n      y = -0.8;\n      break;\n  }\n\n  juliaXEl.value = x;\n  juliaYEl.value = y;\n\n  updateJuliaVectorFromSliders();\n}\n\nlet juliaAnimationState = true;\nlet juliaAnimationFirst = true;\n\nfunction juliaAnimation() {\n  if (juliaAnimationFirst) {\n    maxIterationEl.value = 10;\n  }\n\n  if (juliaAnimationState) {\n    juliaXEl.value = parseFloat(juliaXEl.value) - 0.04;\n    if (juliaXEl.value < -1.9) juliaAnimationState = false;\n  } else {\n    juliaXEl.value = parseFloat(juliaXEl.value) + 0.04;\n    if (juliaXEl.value > -0.05) juliaAnimationState = true;\n  }\n\n  setMaxIterationFromSlider();\n\n  updateJuliaVectorFromSliders();\n\n  //requestAnimationFrame(juliaAnimation);\n\n  if (juliaXEl.value < 0.6) {\n    //juliaXEl.value = juliaXEl.value + 0.01;\n  }\n}\n\nconst introductionEl = document.getElementById('introduction');\n\nintroductionEl.onclick = () => {\n  introductionEl.style.display = 'none';\n};\n\nfunction updateJuliaVectorFromSliders() {\n  WasmHandler.setWorkerSettings('juliaVectorX', parseFloat(juliaXEl.value));\n  WasmHandler.setWorkerSettings('juliaVectorY', parseFloat(juliaYEl.value));\n}\n\nconst locationsEl = document.getElementById('locations');\nfunction generateLocationButtons() {\n  for (let loc of locations) {\n    let el = document.createElement('button');\n    el.textContent = loc.name;\n    el.onclick = function () { gotoLocation(this.textContent); };\n\n    locationsEl.appendChild(el);\n  }\n}\n\ngenerateLocationButtons();\n\nconst locationInterpolateProgressBarEl = document.getElementById('locationInterpolateProgressBar');\nlet transitionTopScale = 1.19;\nlet transitionSpeed = 1;\n\nasync function gotoLocation(locationName) {\n  let loc = locations.find((x) => x.name === locationName);\n\n  let oXCam = Number(xCam);\n  let oYCam = Number(yCam);\n  let oScale = Number(scale);\n\n  locationInterpolateProgressBarEl.value = 0;\n  locationInterpolateProgressBarEl.className = 'show';\n\n  let t = 0;\n  let scaleT = 0;\n\n  let transitionPoint = [-1, 0];\n  let everZoomedOut = false;\n  while (t < 1 || scaleT < 1) {/// || (xCam !== loc.xCam && yCam !== loc.yCam && scale !== loc.scale)) {\n    if (t < 1) {\n      xCam = bezierInterpolate(oXCam, loc.xCam, t);\n      yCam = bezierInterpolate(oYCam, loc.yCam, t);\n    }\n\n    if ((Math.abs(xCam - loc.xCam) > 0.8 || Math.abs(yCam - loc.yCam) > 0.8) && (transitionTopScale > loc.scale && transitionTopScale > scale && transitionTopScale > oScale)) {\n      everZoomedOut = true;\n      if (transitionPoint[0] !== 1) {\n        transitionPoint = [1, scale];\n        scaleT = 0;\n      }\n\n      scale = bezierInterpolate(transitionPoint[1], transitionTopScale, scaleT);\n    } else {\n      if (transitionPoint[0] !== 0) {\n        transitionPoint = [0, scale];\n        scaleT = 0;\n      }\n\n      scale = bezierInterpolate(transitionPoint[1], loc.scale, scaleT);\n    }\n\n    t += 0.005;\n    scaleT += everZoomedOut ? 0.007 : 0.005;\n    if (scaleT > 1) scaleT = 1;\n    if (t > 1) t = 1;\n\n    locationInterpolateProgressBarEl.value = bezierBlend(Math.min(t, 1));\n\n    await (new Promise(resolve => setTimeout(resolve, 10 / transitionSpeed)));\n  }\n\n  locationInterpolateProgressBarEl.className = '';\n\n  //gotoLocationInterval = setInterval(() => { stepToLocation(loc); }, 10);\n}\n\nlet transitionSpeedEl = document.getElementById('transitionSpeed');\n\ntransitionSpeedEl.oninput = () => {\n  transitionSpeed = parseFloat(transitionSpeedEl.value);\n  console.log(transitionSpeed);\n};\n\nfunction bezierInterpolate(a, b, t) {\n  let bezierT = bezierBlend(t);\n\n  return (1 - bezierT) * a + bezierT * b;\n}\n\nfunction bezierBlend(t) {\n  return t * t * (3 - 2 * t);\n}\n\nfunction scaleCanvas() {\n  width = Math.floor(window.innerWidth / scaleFactor);\n  height = Math.floor(window.innerHeight / scaleFactor);\n\n  canvas.width = width;\n  canvas.height = height;\n\n  canvas.style.width = `${window.innerWidth}px`;\n  canvas.style.height = `${window.innerHeight}px`;\n}\n\nlet loadingEl = document.getElementById('loading');\n\ncanvas = document.getElementById('canvas');\nctx = canvas.getContext('2d');\n\nconst multithreadingInitLoadTime = await WasmHandler.init(ctx, (x) => {\n  loadingEl.textContent = x;\n\n  if (x === 'Loaded all multithreading workers') {\n    loadingEl.textContent = x;\n  }\n});\n\nscaleCanvas();\nwindow.onresize = scaleCanvas;\n\ndocument.oncontextmenu = function(e) {\n  e.preventDefault();\n  return false;\n};\n\nfunction generateKeyName(e) {\n  return (e.ctrlKey ? 'ctrl_' : '') + (e.shiftKey ? 'shift_' : '') + e.key.toLowerCase();\n}\n  \ndocument.onkeydown = function(e) {\n  let name = generateKeyName(e);\n\n  if (keys[name] !== 'override') keys[name] = true;\n\n  if (name === 'ctrl_=' || name === 'ctrl_-') {\n    e.preventDefault();\n  }\n};\n\ndocument.onkeyup = function(e) {\n  keys[generateKeyName(e)] = false;\n};\n\nlet dragging = false;\nlet lastDragX = 0;\nlet lastDragY = 0;\n\nfunction mousePanAmount() {\n  return 0.0025 * scale;\n}\n\nfunction mouseDownHandler(e) {\n  if (e.which === 3) { // Right click - auto zoom\n    if (autozoom === false) {\n      autozoom = {clientX: e.clientX, clientY: e.clientY, deltaY: -autozoomSpeed};\n      autozoomInterval = setInterval(() => { wheelHandler(autozoom); }, 10);\n    } else {\n      clearInterval(autozoomInterval);\n      autozoom = false;\n    }\n\n    return;\n  }\n\n  dragging = true;\n\n  lastDragX = e.clientX;\n  lastDragY = e.clientY;\n\n  //WasmHandler.setHandlerSetting('combineMultithreadedData', true);\n}\n\nfunction mouseMoveHandler(e) {\n  if (!dragging) return;\n\n  //let diffX = x - lastDragX;\n  //let diffY = y - lastDragY;\n\n  let mouseInMandelBeforeX = scaleX(e.clientX / scaleFactor) - xCam;\n  let mouseInMandelBeforeY = scaleY(e.clientY / scaleFactor) - yCam;\n\n  if (lastDragX === 0 && lastDragY === 0) {\n    lastDragX = mouseInMandelBeforeX;\n    lastDragY = mouseInMandelBeforeY;\n  }\n\n  console.log(mouseInMandelBeforeX, lastDragX);\n  console.log(mouseInMandelBeforeY, lastDragY);\n\n  xCam -= mouseInMandelBeforeX - lastDragX; // * mousePanAmount();\n  yCam -= mouseInMandelBeforeY - lastDragY; // * mousePanAmount();\n\n  lastDragX = mouseInMandelBeforeX;\n  lastDragY = mouseInMandelBeforeY;\n}\n\nfunction mouseUpHandler(e) {\n  dragging = false;\n\n  //WasmHandler.setHandlerSetting('combineMultithreadedData', false);\n}\n\nfunction scaleX(x) {\n  return ((x / (width / 3.5)) - 1.75) * scale + xCam;\n}\n\nfunction scaleY(y) {\n  return (((y / (height / 2.0)) - 1.0)) * scale + yCam;\n}\n\nfunction wheelHandler(e) {\n  let zoom = (e.deltaY * 0.001);\n\n  //xCam -= ((scaleX(e.clientX / scaleFactor) * zoom) - xCam) / scaleFactor;\n\n  let mouseInMandelBeforeX = scaleX(e.clientX / scaleFactor) - xCam;\n  let mouseInMandelBeforeY = scaleY(e.clientY / scaleFactor) - yCam;\n\n  //console.log(mouseInMandelBeforeX);\n\n  scale *= 1 + zoom;\n\n  xCam -= (scaleX(e.clientX / scaleFactor) - xCam) - mouseInMandelBeforeX;\n\n  yCam -= (scaleY(e.clientY / scaleFactor) - yCam) - mouseInMandelBeforeY;\n\n  //let diffX = (scaleX(e.clientX / scaleFactor) - xCam) + mouseInMandelBeforeX;\n  //console.log(diffX)\n\n  //xCam += diffX;\n\n  //xCam -= scaleX(e.clientX) * zoom / scaleFactor;\n\n  //xCam = xCam - scaleX(e.clientX / window.innerWidth * (sWidthAfter - sWidthBefore));\n  //yCam = yCam - scaleY(e.clientY / window.innerHeight * (sHeightAfter - sHeightBefore));\n\n  if (e.preventDefault) e.preventDefault();\n}\n\ncanvas.onmousedown = mouseDownHandler;\ncanvas.onmousemove = mouseMoveHandler;\ncanvas.onmouseup = mouseUpHandler;\n\ncanvas.onwheel = wheelHandler;\n\nlet lastUpdateTime = performance.now();\n\nlet panAmount = 0.02;\n\nfunction scalePanAmount() {\n  return panAmount * scale;\n}\n\nlet settingsEl = document.getElementById('settings');\nlet locationsContainerEl = document.getElementById('locationsContainer');\n\nlet introIterationAnimation = true;\n\nlet settingsShowing = true;\n\nasync function update() {\n  let timeNow = performance.now();\n  let deltaTime = (timeNow - lastUpdateTime) / 1000;\n  lastUpdateTime = timeNow;\n\n  //juliaAnimation();\n\n  fpsArr.push(Math.round(1 / deltaTime));\n  if (fpsArr.length > 10) fpsArr.shift();\n\n  if (introIterationAnimation) {\n    let newValue = parseInt(maxIterationEl.value);\n    maxIterationEl.value = Math.ceil(newValue * 1.15); // > 100 ? newValue + 7 : newValue;\n\n    if (newValue > 500) { // || Object.values(keys).some((x) => x)) { // If maxIteration reaches 500 or any keys pressed\n      maxIterationEl.value = 500;\n      introIterationAnimation = false;\n    }\n\n    setMaxIterationFromSlider();\n  }\n\n  if (keys['w'] || keys['arrowup']) {\n    yCam -= scalePanAmount();\n  }\n\n  if (keys['s'] || keys['arrowdown']) {\n    yCam += scalePanAmount();\n  }\n\n  if (keys['a'] || keys['arrowleft']) {\n    xCam -= scalePanAmount();\n  }\n\n  if (keys['d'] || keys['arrowright']) {\n    xCam += scalePanAmount();\n  }\n\n  if (keys['z'] || keys['ctrl_=']) {\n    scale *= 0.99;\n  }\n\n  if (keys['x'] || keys['ctrl_-']) {\n    scale *= 1.01;\n  }\n\n  if (keys['0'] === true) {\n    gotoLocation(locations[0].name);\n    keys['0'] = 'override';\n  }\n\n  if (keys[']'] === true) {\n    juliaSelection++;\n    if (juliaSelection > 9) juliaSelection = 0;\n    setJuliaVector();\n\n    keys[']'] = 'override';\n  }\n\n  if (keys['h'] === true) {\n    settingsShowing = !settingsShowing;\n\n    settingsEl.style.display = settingsShowing ? 'block' : 'none';\n\n    keys['h'] = 'override';\n  }\n\n  if (keys['shift_h'] === true) {\n    locationsContainerEl.style.display = locationsContainerEl.style.display === 'block' ? 'none' : 'block';\n\n    keys['shift_h'] = 'override';\n  }\n\n  await WasmHandler.renderFrame(width, height, xCam, yCam, scale);\n\n  frame++;\n\n  if (settingsShowing) drawDebug();\n\n  requestAnimationFrame(update);\n}\n\nlet debugEl = document.getElementById('debug');\n\nlet resScaleEl = document.getElementById('resScale');\n\nresScaleEl.oninput = () => {\n  scaleFactor = resScaleEl.value;\n\n  scaleCanvas();\n};\n\nlet maxIterationEl = document.getElementById('maxIteration');\n\nfunction setMaxIterationFromSlider() {\n  WasmHandler.setWorkerSettings('maxIteration', maxIterationEl.value);\n  WasmHandler.setWorkerSettings('maxIterationColorScale', 255 / maxIterationEl.value);\n}\n\nmaxIterationEl.oninput = setMaxIterationFromSlider;\n\nlet autozoomSpeedEl = document.getElementById('autozoomSpeed');\n\nautozoomSpeedEl.oninput = () => {\n  autozoomSpeed = autozoomSpeedEl.value;\n  if (autozoom !== false) autozoom.deltaY = -autozoomSpeed;\n}\n\nlet linesBetweenEl = document.getElementById('linesBetween');\n\nlinesBetweenEl.oninput = () => {\n  WasmHandler.setWorkerSettings('linesBetweenMultithreadColumns', linesBetweenEl.checked);\n};\n\nlet borderTracingEl = document.getElementById('borderTracing');\n\nborderTracingEl.oninput = () => {\n  WasmHandler.setWorkerSettings('useBorderTracing', borderTracingEl.checked);\n};\n\nlet combineDataEl = document.getElementById('combineData');\n\ncombineDataEl.oninput = () => {\n  WasmHandler.setHandlerSetting('combineMultithreadedData', combineDataEl.checked);\n};\n\nfunction arrAverage(arr) {\n  return arr.reduce((a, b) => a + b) / arr.length;\n}\n\nasync function drawDebug() {\n  let fps = Math.round(arrAverage(fpsArr));\n\n  debugEl.textContent = `${version}\n\nLoad Time - ${startLoadTime.toFixed(2)}ms:\n  Multithreading: ${multithreadingInitLoadTime.toFixed(2)}ms\n\nFrames: ${frame}, FPS: ${fps}\n\nPosition Information:\n  Camera Position: ${xCam.toPrecision(8)}, ${yCam.toPrecision(8)}\n  Scale: ${scale.toPrecision(8)}\n\nResolution:\n  Scaled: ${width}x${height}\n  Scale Factor: ${scaleFactor}\n  Raw: ${window.innerWidth}x${window.innerHeight}\n\nMultithreading:\n  Workers (Threads): ${WasmHandler.multithreadingAmount} (Assumed: ${WasmHandler.failedToGetThreadCount})\n\nMemory (Heap): ${(window.performance.memory.usedJSHeapSize / 1000000).toFixed(2)}MB used / ${(window.performance.memory.totalJSHeapSize / 1000000).toFixed(2)}MB total`;\n}\n\n/*async function autoGeneratePerformance() {\n  let times = [];\n\n  for (let i = 0; i < 2; i++) {\n    let startTime = performance.now();\n\n    await WasmHandler.renderFrame(width, height, xCam, yCam, scale);\n\n    times.push(performance.now() - startTime);\n  }\n\n  let timeTaken = arrAverage(times);\n\n  loadingEl.textContent = `Auto modifying values for good performance... (${timeTaken.toFixed(0)}ms / ${(1000 / 15).toFixed(0)}ms)`;\n\n  if (timeTaken < 1000 / 15) {\n    let current = Number(maxIterationEl.value);\n    maxIterationEl.value = current + 20; //(parseInt(maxIterationEl.value) - 5).toString();\n    setMaxIterationFromSlider();\n\n    await (new Promise(resolve => setTimeout(resolve, 10)));\n\n    await autoGeneratePerformance();\n  }\n}*/\n\n/*async function increaseMaxIterationAnimation() {\n  await (new Promise(resolve => setTimeout(resolve, 200)));\n\n  if (maxIterationEl.value < 500) {\n    maxIterationEl.value = parseInt(maxIterationEl.value) + 10;\n    console.log(maxIterationEl.value);\n    setMaxIterationFromSlider();\n\n    //await (new Promise(resolve => setTimeout(resolve, 100)));\n\n    await increaseMaxIterationAnimation();\n  }\n}*/\n\nloadingEl.className = 'hide';\n//increaseMaxIterationAnimation();\n\n\n//loadingEl.textContent = 'Auto modifying values for good performance...';\n\n//await autoGeneratePerformance();\n\nconst startLoadTime = performance.now() - timeSinceStart;\n\nupdate();\n})();"]}