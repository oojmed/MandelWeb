{"version":3,"sources":["js/wasmMultithread.js","../node_modules/parcel-bundler/src/builtins/bundle-url.js","../node_modules/parcel-bundler/src/builtins/bundle-loader.js","../node_modules/parcel-plugin-wasm.rs/wasm-loader.js"],"names":["defaultMaxIteration","settings","linesBetweenMultithreadColumns","maxIteration","maxIterationColorScale","usehistogramColoring","useSmoothColoring","juliaVectorX","juliaVectorY","onmessage","e","data","length","type","key","value","postMessage","width","height","module","gen_histo_data","i","renderWidth","actualWidth","xCam","yCam","scale","histoColors","xOffset","result","gen_data","bundleURL","getBundleURLCached","getBundleURL","Error","err","matches","stack","match","getBaseURL","url","replace","exports","require","loadBundlesLazy","bundles","Array","isArray","id","Promise","resolve","code","LazyPromise","reject","loadBundles","slice","then","all","map","loadBundle","bundleLoaders","registerBundleLoader","loader","load","register","bundle","substring","lastIndexOf","toLowerCase","bundleLoader","resolved","catch","executor","promise","prototype","onSuccess","onError"],"mappings":"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","file":"wasmMultithread.b84178ca.js","sourceRoot":"../src","sourcesContent":["import module from '../../wasm/Cargo.toml';\n\nlet defaultMaxIteration = 500;\n\nlet settings = {\n  linesBetweenMultithreadColumns: false,\n  maxIteration: defaultMaxIteration,\n  maxIterationColorScale: 255 / defaultMaxIteration,\n  usehistogramColoring: false,\n  useSmoothColoring: false,\n  juliaVectorX: 0,\n  juliaVectorY: 0\n};\n\nonmessage = (e) => {\n  if (e.data.length === 3) { // Set / get setting\n    let [type, key, value] = e.data;\n\n    if (type === 'set') {\n      settings[key] = value;\n\n      return;\n    } else { // Get\n      postMessage(['gotSetting', settings[key]]);\n    }\n\n    return;\n  }\n\n  if (e.data.length === 2) { // generate and send histograph colors\n    let [width, height] = e.data;\n\n    postMessage([module.gen_histo_data(settings.maxIteration, settings.juliaVectorX, settings.juliaVectorY, width, height)]);\n\n    return;\n  }\n\n  //console.log(self.linesBetweenMultithreadColumn);\n  let [i, renderWidth, actualWidth, height, xCam, yCam, scale, histoColors] = e.data;\n  let xOffset = (i * renderWidth);\n\n  let result = module.gen_data(histoColors, settings.linesBetweenMultithreadColumns, settings.usehistogramColoring, settings.useSmoothColoring, settings.maxIteration, settings.maxIterationColorScale, settings.juliaVectorX, settings.juliaVectorY, renderWidth, actualWidth, xOffset, height, xCam, yCam, scale);\n  postMessage([i, renderWidth, height, result]);\n  //postMessage([i, width, height, xCam, yCam, scale]);\n\n  //module.render_frame()\n  //postMessage(e.data.toString());\n  //postMessage(module.render_frame())\n};\n\npostMessage('loaded');","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var getBundleURL = require('./bundle-url').getBundleURL;\n\nfunction loadBundlesLazy(bundles) {\n  if (!Array.isArray(bundles)) {\n    bundles = [bundles]\n  }\n\n  var id = bundles[bundles.length - 1];\n\n  try {\n    return Promise.resolve(require(id));\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      return new LazyPromise(function (resolve, reject) {\n        loadBundles(bundles.slice(0, -1))\n          .then(function () {\n            return require(id);\n          })\n          .then(resolve, reject);\n      });\n    }\n\n    throw err;\n  }\n}\n\nfunction loadBundles(bundles) {\n  return Promise.all(bundles.map(loadBundle));\n}\n\nvar bundleLoaders = {};\nfunction registerBundleLoader(type, loader) {\n  bundleLoaders[type] = loader;\n}\n\nmodule.exports = exports = loadBundlesLazy;\nexports.load = loadBundles;\nexports.register = registerBundleLoader;\n\nvar bundles = {};\nfunction loadBundle(bundle) {\n  var id;\n  if (Array.isArray(bundle)) {\n    id = bundle[1];\n    bundle = bundle[0];\n  }\n\n  if (bundles[bundle]) {\n    return bundles[bundle];\n  }\n\n  var type = (bundle.substring(bundle.lastIndexOf('.') + 1, bundle.length) || bundle).toLowerCase();\n  var bundleLoader = bundleLoaders[type];\n  if (bundleLoader) {\n    return bundles[bundle] = bundleLoader(getBundleURL() + bundle)\n      .then(function (resolved) {\n        if (resolved) {\n          module.bundle.register(id, resolved);\n        }\n\n        return resolved;\n      }).catch(function(e) {\n        delete bundles[bundle];\n        \n        throw e;\n      });\n  }\n}\n\nfunction LazyPromise(executor) {\n  this.executor = executor;\n  this.promise = null;\n}\n\nLazyPromise.prototype.then = function (onSuccess, onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.then(onSuccess, onError)\n};\n\nLazyPromise.prototype.catch = function (onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.catch(onError)\n};\n","var wasm;const __exports = {};\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @param {number} maxIteration\n* @param {number} juliaVectorX\n* @param {number} juliaVectorY\n* @param {number} width\n* @param {number} height\n* @returns {Array<any>}\n*/\n__exports. gen_histo_data = function(maxIteration, juliaVectorX, juliaVectorY, width, height) {\n    var ret = wasm.gen_histo_data(maxIteration, juliaVectorX, juliaVectorY, width, height);\n    return takeObject(ret);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Uint8Array} histoColors\n* @param {boolean} linesBetweenColumns\n* @param {boolean} usehistogramColoring\n* @param {boolean} useSmoothColoring\n* @param {number} maxIteration\n* @param {number} maxIterationColorScale\n* @param {number} juliaVectorX\n* @param {number} juliaVectorY\n* @param {number} renderWidth\n* @param {number} actualWidth\n* @param {number} xOffset\n* @param {number} height\n* @param {number} xCam\n* @param {number} yCam\n* @param {number} scale\n* @returns {Uint8ClampedArray}\n*/\n__exports. gen_data = function(histoColors, linesBetweenColumns, usehistogramColoring, useSmoothColoring, maxIteration, maxIterationColorScale, juliaVectorX, juliaVectorY, renderWidth, actualWidth, xOffset, height, xCam, yCam, scale) {\n    var ptr0 = passArray8ToWasm0(histoColors, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.gen_data(ptr0, len0, linesBetweenColumns, usehistogramColoring, useSmoothColoring, maxIteration, maxIterationColorScale, juliaVectorX, juliaVectorY, renderWidth, actualWidth, xOffset, height, xCam, yCam, scale);\n    return takeObject(ret);\n}\n\n__exports.__wbindgen_number_new = function(arg0) {\n    var ret = arg0;\n    return addHeapObject(ret);\n};\n\n__exports.__wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\n__exports.__wbg_new_17534eac4df3cd22 = function() {\n    var ret = new Array();\n    return addHeapObject(ret);\n};\n\n__exports.__wbg_push_7114ccbf1c58e41f = function(arg0, arg1) {\n    var ret = getObject(arg0).push(getObject(arg1));\n    return ret;\n};\n\n__exports.__wbg_newwithlength_eb6b351ada971d55 = function(arg0) {\n    var ret = new Uint8ClampedArray(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\n__exports.__wbg_setindex_ab27c5758a457930 = function(arg0, arg1, arg2) {\n    getObject(arg0)[arg1 >>> 0] = arg2;\n};\n\n__exports.__wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n\n      function init(wasm_path) {\n          const fetchPromise = fetch(wasm_path);\n          let resultPromise;\n          if (typeof WebAssembly.instantiateStreaming === 'function') {\n              resultPromise = WebAssembly.instantiateStreaming(fetchPromise, { './mandelweb_wasm_bg.js': __exports });\n          } else {\n              resultPromise = fetchPromise\n              .then(response => response.arrayBuffer())\n              .then(buffer => WebAssembly.instantiate(buffer, { './mandelweb_wasm_bg.js': __exports }));\n          }\n          return resultPromise.then(({instance}) => {\n              wasm = init.wasm = instance.exports;\n              __exports.wasm = wasm;\n              return;\n          });\n      };\n      function init_node(wasm_path) {\n          const fs = require('fs');\n          return new Promise(function(resolve, reject) {\n              fs.readFile(__dirname + wasm_path, function(err, data) {\n                  if (err) {\n                      reject(err);\n                  } else {\n                      resolve(data.buffer);\n                  }\n              });\n          })\n          .then(data => WebAssembly.instantiate(data, { './mandelweb_wasm_bg': __exports }))\n          .then(({instance}) => {\n              wasm = init.wasm = instance.exports;\n              __exports.wasm = wasm;\n              return;\n          });\n      }\n      const wasm_bindgen = Object.assign(false ? init_node : init, __exports);\n      module.exports = function loadWASMBundle(bundle) {\n            return wasm_bindgen(bundle).then(() => __exports)\n      }\n    "]}